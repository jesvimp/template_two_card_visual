import {
  __commonJS
} from "./chunk-DZZM6G22.js";

// node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/semver/internal/constants.js"(exports, module) {
    "use strict";
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/semver/internal/debug.js"(exports, module) {
    "use strict";
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module.exports = debug;
  }
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/semver/internal/re.js"(exports, module) {
    "use strict";
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug = require_debug();
    exports = module.exports = {};
    var re = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src = exports.src = [];
    var safeSrc = exports.safeSrc = [];
    var t = exports.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug(name, index, value);
      t[name] = index;
      src[index] = value;
      safeSrc[index] = safe;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/semver/internal/parse-options.js"(exports, module) {
    "use strict";
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module.exports = parseOptions;
  }
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/semver/internal/identifiers.js"(exports, module) {
    "use strict";
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      if (typeof a === "number" && typeof b === "number") {
        return a === b ? 0 : a < b ? -1 : 1;
      }
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/semver/classes/semver.js"(exports, module) {
    "use strict";
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version, options) {
        options = parseOptions(options);
        if (version instanceof _SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.major < other.major) {
          return -1;
        }
        if (this.major > other.major) {
          return 1;
        }
        if (this.minor < other.minor) {
          return -1;
        }
        if (this.minor > other.minor) {
          return 1;
        }
        if (this.patch < other.patch) {
          return -1;
        }
        if (this.patch > other.patch) {
          return 1;
        }
        return 0;
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("build compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        if (release.startsWith("pre")) {
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (identifier) {
            const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);
            if (!match || match[1] !== identifier) {
              throw new Error(`invalid identifier: ${identifier}`);
            }
          }
        }
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "release":
            if (this.prerelease.length === 0) {
              throw new Error(`version ${this.raw} is not a prerelease`);
            }
            this.prerelease.length = 0;
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module.exports = SemVer;
  }
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/semver/functions/parse.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var parse = (version, options, throwErrors = false) => {
      if (version instanceof SemVer) {
        return version;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module.exports = parse;
  }
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/semver/functions/valid.js"(exports, module) {
    "use strict";
    var parse = require_parse();
    var valid = (version, options) => {
      const v = parse(version, options);
      return v ? v.version : null;
    };
    module.exports = valid;
  }
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/semver/functions/clean.js"(exports, module) {
    "use strict";
    var parse = require_parse();
    var clean = (version, options) => {
      const s = parse(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module.exports = clean;
  }
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/semver/functions/inc.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var inc = (version, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version instanceof SemVer ? version.version : version,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module.exports = inc;
  }
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/semver/functions/diff.js"(exports, module) {
    "use strict";
    var parse = require_parse();
    var diff = (version1, version2) => {
      const v1 = parse(version1, null, true);
      const v2 = parse(version2, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (lowVersion.compareMain(highVersion) === 0) {
          if (lowVersion.minor && !lowVersion.patch) {
            return "minor";
          }
          return "patch";
        }
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v2.major) {
        return prefix + "major";
      }
      if (v1.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module.exports = diff;
  }
});

// node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/semver/functions/major.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module.exports = major;
  }
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/semver/functions/minor.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module.exports = minor;
  }
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/semver/functions/patch.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module.exports = patch;
  }
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/semver/functions/prerelease.js"(exports, module) {
    "use strict";
    var parse = require_parse();
    var prerelease = (version, options) => {
      const parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module.exports = prerelease;
  }
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/semver/functions/compare.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module.exports = compare;
  }
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/semver/functions/rcompare.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module.exports = rcompare;
  }
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/semver/functions/compare-loose.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module.exports = compareLoose;
  }
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/semver/functions/compare-build.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module.exports = compareBuild;
  }
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/semver/functions/sort.js"(exports, module) {
    "use strict";
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module.exports = sort;
  }
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/semver/functions/rsort.js"(exports, module) {
    "use strict";
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module.exports = rsort;
  }
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/semver/functions/gt.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module.exports = gt;
  }
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/semver/functions/lt.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module.exports = lt;
  }
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/semver/functions/eq.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module.exports = eq;
  }
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/semver/functions/neq.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module.exports = neq;
  }
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/semver/functions/gte.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module.exports = gte;
  }
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/semver/functions/lte.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module.exports = lte;
  }
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/semver/functions/cmp.js"(exports, module) {
    "use strict";
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module.exports = cmp;
  }
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/semver/functions/coerce.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var parse = require_parse();
    var { safeRe: re, t } = require_re();
    var coerce = (version, options) => {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);
    };
    module.exports = coerce;
  }
});

// node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "node_modules/semver/internal/lrucache.js"(exports, module) {
    "use strict";
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module.exports = LRUCache;
  }
});

// node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/semver/classes/range.js"(exports, module) {
    "use strict";
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i = 0; i < this.set.length; i++) {
            if (i > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i];
            for (let k = 0; k < comps.length; k++) {
              if (k > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module.exports = Range;
    var LRU = require_lrucache();
    var cache = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      comp = comp.replace(re[t.BUILD], "");
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/semver/classes/comparator.js"(exports, module) {
    "use strict";
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/semver/functions/satisfies.js"(exports, module) {
    "use strict";
    var Range = require_range();
    var satisfies = (version, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    };
    module.exports = satisfies;
  }
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/semver/ranges/to-comparators.js"(exports, module) {
    "use strict";
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module.exports = toComparators;
  }
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/semver/ranges/max-satisfying.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module.exports = maxSatisfying;
  }
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/semver/ranges/min-satisfying.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module.exports = minSatisfying;
  }
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/semver/ranges/min-version.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module.exports = minVersion;
  }
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/semver/ranges/valid.js"(exports, module) {
    "use strict";
    var Range = require_range();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module.exports = validRange;
  }
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/semver/ranges/outside.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version, range, hilo, options) => {
      version = new SemVer(version, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module.exports = outside;
  }
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/semver/ranges/gtr.js"(exports, module) {
    "use strict";
    var outside = require_outside();
    var gtr = (version, range, options) => outside(version, range, ">", options);
    module.exports = gtr;
  }
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/semver/ranges/ltr.js"(exports, module) {
    "use strict";
    var outside = require_outside();
    var ltr = (version, range, options) => outside(version, range, "<", options);
    module.exports = ltr;
  }
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/semver/ranges/intersects.js"(exports, module) {
    "use strict";
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    };
    module.exports = intersects;
  }
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/semver/ranges/simplify.js"(exports, module) {
    "use strict";
    var satisfies = require_satisfies();
    var compare = require_compare();
    module.exports = (versions, range, options) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version of v) {
        const included = satisfies(version, range, options);
        if (included) {
          prev = version;
          if (!first) {
            first = version;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/semver/ranges/subset.js"(exports, module) {
    "use strict";
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module.exports = subset;
  }
});

// node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/semver/index.js"(exports, module) {
    "use strict";
    var internalRe = require_re();
    var constants = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse = require_parse();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module.exports = {
      parse,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/powerbi-visuals-api/package.json
var require_package = __commonJS({
  "node_modules/powerbi-visuals-api/package.json"(exports, module) {
    module.exports = {
      name: "powerbi-visuals-api",
      version: "5.3.0",
      description: "Power BI Custom Visuals API type definitions for typescript",
      types: "index",
      main: "index.js",
      keywords: [
        "PowerBI",
        "BI",
        "visuals",
        "visualization"
      ],
      repository: {
        type: "git",
        url: "https://github.com/microsoft/powerbi-visuals-api.git"
      },
      author: "Microsoft",
      license: "MIT",
      bugs: {
        url: "https://github.com/Microsoft/PowerBI-visuals-tools/issues"
      },
      homepage: "https://microsoft.github.io/PowerBI-visuals",
      dependencies: {
        semver: "^7.3.5"
      },
      devDependencies: {
        jasmine: "^3.9.0"
      },
      scripts: {
        test: "jasmine"
      }
    };
  }
});

// node_modules/powerbi-visuals-api/schema.capabilities.json
var require_schema_capabilities = __commonJS({
  "node_modules/powerbi-visuals-api/schema.capabilities.json"(exports, module) {
    module.exports = {
      type: "object",
      properties: {
        privileges: {
          type: "array",
          description: "Defines required privileges for the visual",
          items: {
            $ref: "#/definitions/privilege"
          }
        },
        dataRoles: {
          type: "array",
          description: "Defines data roles for the visual",
          items: {
            $ref: "#/definitions/dataRole"
          }
        },
        dataViewMappings: {
          type: "array",
          description: "Defines data mappings for the visual",
          items: {
            $ref: "#/definitions/dataViewMapping"
          }
        },
        objects: {
          $ref: "#/definitions/objects"
        },
        tooltips: {
          $ref: "#/definitions/tooltips"
        },
        sorting: {
          $ref: "#/definitions/sorting"
        },
        drilldown: {
          $ref: "#/definitions/drilldown"
        },
        expandCollapse: {
          $ref: "#/definitions/expandCollapse"
        },
        suppressDefaultTitle: {
          type: "boolean",
          description: "Indicates whether the visual should show a default title"
        },
        supportsKeyboardFocus: {
          type: "boolean",
          description: "Allows the visual to receive focus through keyboard navigation"
        },
        supportsHighlight: {
          type: "boolean",
          description: "Tells the host to include highlight data"
        },
        supportsSynchronizingFilterState: {
          type: "boolean",
          description: "Indicates whether the visual supports synchronization across report pages (for slicer visuals only)"
        },
        advancedEditModeSupport: {
          type: "number",
          description: "Indicates the action requested from the host when this visual enters Advanced Edit mode."
        },
        supportsLandingPage: {
          type: "boolean",
          description: "Indicates whether the visual supports a landing page"
        },
        supportsEmptyDataView: {
          type: "boolean",
          description: "Indicates whether the visual can receive formatting pane properties when it has no dataroles"
        },
        supportsMultiVisualSelection: {
          type: "boolean",
          description: "Indicates whether the visual supports multi selection"
        },
        subtotals: {
          description: "Specifies the subtotal customizations applied in the customizeQuery method",
          $ref: "#/definitions/subtotals"
        },
        migration: {
          $ref: "#/definitions/migration"
        },
        keepAllMetadataColumns: {
          type: "boolean",
          description: "Indicates that visual is going to receive all metadata columns, no matter what the active projections are"
        },
        dataReductionCustomization: {
          description: "Specifies the dataReduction customization applied in the customQuery method",
          $ref: "#/definitions/dataReductionCustomization"
        }
      },
      required: [
        "privileges"
      ],
      additionalProperties: false,
      definitions: {
        privilege: {
          type: "object",
          description: "privilege - Defines the name, essentiality, and optional parameters for a privilege",
          properties: {
            name: {
              type: "string",
              description: "The internal name of the privilege",
              enum: [
                "WebAccess",
                "LocalStorage",
                "ExportContent"
              ]
            },
            essential: {
              type: "boolean",
              description: "Determines if the privilege is essential for the visual. Default value is false"
            },
            parameters: {
              type: "array",
              description: "Determines a list of privilege parameters if any",
              items: {
                type: "string",
                description: "The privilege parameter"
              }
            }
          },
          required: [
            "name"
          ]
        },
        dataRole: {
          type: "object",
          description: "dataRole - Defines the name, displayName, and kind of a data role",
          properties: {
            name: {
              type: "string",
              description: "The internal name for this data role used for all references to this role"
            },
            displayName: {
              type: "string",
              description: "The name of this data role that is shown to the user"
            },
            displayNameKey: {
              type: "string",
              description: "The localization key for the displayed name in the stringResourced file"
            },
            kind: {
              description: "The kind of data that can be bound do this role",
              $ref: "#/definitions/dataRole.kind"
            },
            description: {
              type: "string",
              description: "A description of this role shown to the user as a tooltip"
            },
            descriptionKey: {
              type: "string",
              description: "The localization key for the description in the stringResourced file"
            },
            preferredTypes: {
              type: "array",
              description: "Defines the preferred type of data for this data role",
              items: {
                $ref: "#/definitions/valueType"
              }
            },
            requiredTypes: {
              type: "array",
              description: "Defines the required type of data for this data role. Any values that do not match will be set to null",
              items: {
                $ref: "#/definitions/valueType"
              }
            }
          },
          required: [
            "name",
            "displayName",
            "kind"
          ],
          additionalProperties: false
        },
        dataViewMapping: {
          type: "object",
          description: "dataMapping - Defines how data is mapped to data roles",
          properties: {
            conditions: {
              type: "array",
              description: "List of conditions that must be met for this data mapping",
              items: {
                type: "object",
                description: "condition - Defines conditions for a data mapping (each key needs to be a valid data role)",
                patternProperties: {
                  "^[\\w\\s-]+$": {
                    description: "Specifies the number of values that can be assigned to this data role in this mapping",
                    $ref: "#/definitions/dataViewMapping.numberRangeWithKind"
                  }
                },
                additionalProperties: false
              }
            },
            single: {
              $ref: "#/definitions/dataViewMapping.single"
            },
            categorical: {
              $ref: "#/definitions/dataViewMapping.categorical"
            },
            table: {
              $ref: "#/definitions/dataViewMapping.table"
            },
            matrix: {
              $ref: "#/definitions/dataViewMapping.matrix"
            },
            scriptResult: {
              $ref: "#/definitions/dataViewMapping.scriptResult"
            }
          },
          anyOf: [
            {
              required: [
                "single"
              ]
            },
            {
              required: [
                "categorical"
              ]
            },
            {
              required: [
                "table"
              ]
            },
            {
              required: [
                "matrix"
              ]
            },
            {
              required: [
                "scriptResult"
              ]
            }
          ],
          additionalProperties: false
        },
        "dataViewMapping.single": {
          type: "object",
          description: "single - Defines a single data mapping",
          properties: {
            role: {
              type: "string",
              description: "The data role to bind to this mapping"
            }
          },
          required: [
            "role"
          ],
          additionalProperties: false
        },
        "dataViewMapping.categorical": {
          type: "object",
          description: "categorical - Defines a categorical data mapping",
          properties: {
            categories: {
              type: "object",
              description: "Defines data roles to be used as categories",
              properties: {
                bind: {
                  $ref: "#/definitions/dataViewMapping.bindTo"
                },
                for: {
                  $ref: "#/definitions/dataViewMapping.forIn"
                },
                select: {
                  $ref: "#/definitions/dataViewMapping.select"
                },
                dataReductionAlgorithm: {
                  $ref: "#/definitions/dataViewMapping.dataReductionAlgorithm"
                }
              },
              oneOf: [
                {
                  required: [
                    "for"
                  ]
                },
                {
                  required: [
                    "bind"
                  ]
                },
                {
                  required: [
                    "select"
                  ]
                }
              ]
            },
            values: {
              type: "object",
              description: "Defines data roles to be used as values",
              properties: {
                bind: {
                  $ref: "#/definitions/dataViewMapping.bindTo"
                },
                for: {
                  $ref: "#/definitions/dataViewMapping.forIn"
                },
                select: {
                  $ref: "#/definitions/dataViewMapping.select"
                },
                group: {
                  type: "object",
                  description: "Groups on a a specific data role",
                  properties: {
                    by: {
                      description: "Specifies a data role to use for grouping",
                      type: "string"
                    },
                    select: {
                      $ref: "#/definitions/dataViewMapping.select"
                    },
                    dataReductionAlgorithm: {
                      $ref: "#/definitions/dataViewMapping.dataReductionAlgorithm"
                    }
                  },
                  required: [
                    "by",
                    "select"
                  ]
                }
              },
              oneOf: [
                {
                  required: [
                    "for"
                  ]
                },
                {
                  required: [
                    "bind"
                  ]
                },
                {
                  required: [
                    "select"
                  ]
                },
                {
                  required: [
                    "group"
                  ]
                }
              ]
            },
            dataVolume: {
              $ref: "#/definitions/dataViewMapping.dataVolume"
            }
          },
          additionalProperties: false
        },
        "dataViewMapping.table": {
          type: "object",
          description: "table - Defines a table data mapping",
          properties: {
            rows: {
              type: "object",
              description: "Rows to use for the table",
              properties: {
                bind: {
                  $ref: "#/definitions/dataViewMapping.bindTo"
                },
                for: {
                  $ref: "#/definitions/dataViewMapping.forIn"
                },
                select: {
                  $ref: "#/definitions/dataViewMapping.select"
                },
                dataReductionAlgorithm: {
                  $ref: "#/definitions/dataViewMapping.dataReductionAlgorithm"
                }
              },
              oneOf: [
                {
                  required: [
                    "for"
                  ]
                },
                {
                  required: [
                    "bind"
                  ]
                },
                {
                  required: [
                    "select"
                  ]
                }
              ]
            },
            rowCount: {
              type: "object",
              description: "Specifies a constraint on the number of data rows supported by the visual",
              properties: {
                preferred: {
                  description: "Specifies a preferred range of values for the constraint",
                  $ref: "#/definitions/dataViewMapping.numberRange"
                },
                supported: {
                  description: "Specifies a supported range of values for the constraint. Defaults to preferred if not specified.",
                  $ref: "#/definitions/dataViewMapping.numberRange"
                }
              }
            },
            dataVolume: {
              $ref: "#/definitions/dataViewMapping.dataVolume"
            }
          },
          requires: [
            "rows"
          ]
        },
        "dataViewMapping.matrix": {
          type: "object",
          description: "matrix - Defines a matrix data mapping",
          properties: {
            rows: {
              type: "object",
              description: "Defines the rows used for the matrix",
              properties: {
                for: {
                  $ref: "#/definitions/dataViewMapping.forIn"
                },
                select: {
                  $ref: "#/definitions/dataViewMapping.select"
                },
                dataReductionAlgorithm: {
                  $ref: "#/definitions/dataViewMapping.dataReductionAlgorithm"
                }
              },
              oneOf: [
                {
                  required: [
                    "for"
                  ]
                },
                {
                  required: [
                    "select"
                  ]
                }
              ]
            },
            columns: {
              type: "object",
              description: "Defines the columns used for the matrix",
              properties: {
                for: {
                  $ref: "#/definitions/dataViewMapping.forIn"
                },
                dataReductionAlgorithm: {
                  $ref: "#/definitions/dataViewMapping.dataReductionAlgorithm"
                }
              },
              required: [
                "for"
              ]
            },
            values: {
              type: "object",
              description: "Defines the values used for the matrix",
              properties: {
                for: {
                  $ref: "#/definitions/dataViewMapping.forIn"
                },
                select: {
                  $ref: "#/definitions/dataViewMapping.select"
                }
              },
              oneOf: [
                {
                  required: [
                    "for"
                  ]
                },
                {
                  required: [
                    "select"
                  ]
                }
              ]
            },
            dataVolume: {
              $ref: "#/definitions/dataViewMapping.dataVolume"
            }
          }
        },
        "dataViewMapping.scriptResult": {
          type: "object",
          description: "scriptResult - Defines a scriptResult data mapping",
          properties: {
            dataInput: {
              type: "object",
              description: "dataInput - Defines how data is mapped to data roles",
              properties: {
                table: {
                  $ref: "#/definitions/dataViewMapping.table"
                }
              }
            },
            script: {
              type: "object",
              description: "script - Defines where the script text and provider are stored",
              properties: {
                scriptSourceDefault: {
                  type: "string",
                  description: "scriptSourceDefault - Defines the default script source value to be used when no script object is defined"
                },
                scriptProviderDefault: {
                  type: "string",
                  description: "scriptProviderDefault - Defines the default script provider value to be used when no provider object is defined"
                },
                scriptOutputType: {
                  type: "string",
                  description: "scriptOutputType - Defines the output type that the R script will generate"
                },
                source: {
                  $ref: "#/definitions/dataViewObjectPropertyIdentifier"
                },
                provider: {
                  $ref: "#/definitions/dataViewObjectPropertyIdentifier"
                }
              }
            }
          }
        },
        dataViewObjectPropertyIdentifier: {
          type: "object",
          description: "Points to an object property",
          properties: {
            objectName: {
              type: "string",
              description: "The name of a object"
            },
            propertyName: {
              type: "string",
              description: "The name of a property inside the object"
            }
          }
        },
        "dataViewMapping.bindTo": {
          type: "object",
          description: "Binds this data mapping to a single value",
          properties: {
            to: {
              type: "string",
              description: "The name of a data role to bind to"
            }
          },
          additionalProperties: false,
          required: [
            "to"
          ]
        },
        "dataViewMapping.numberRange": {
          type: "object",
          description: "A number range from min to max",
          properties: {
            min: {
              type: "number",
              description: "Minimum value supported"
            },
            max: {
              type: "number",
              description: "Maximum value supported"
            }
          }
        },
        "dataViewMapping.numberRangeWithKind": {
          allOf: [
            {
              $ref: "#/definitions/dataViewMapping.numberRange"
            },
            {
              properties: {
                kind: {
                  $ref: "#/definitions/dataRole.kind"
                }
              }
            }
          ]
        },
        "dataRole.kind": {
          type: "string",
          enum: [
            "Grouping",
            "Measure",
            "GroupingOrMeasure"
          ]
        },
        "dataViewMapping.select": {
          type: "array",
          description: "Defines a list of properties to bind",
          items: {
            type: "object",
            properties: {
              bind: {
                $ref: "#/definitions/dataViewMapping.bindTo"
              },
              for: {
                $ref: "#/definitions/dataViewMapping.forIn"
              }
            },
            oneOf: [
              {
                required: [
                  "for"
                ]
              },
              {
                required: [
                  "bind"
                ]
              }
            ]
          }
        },
        "dataViewMapping.dataReductionAlgorithm": {
          type: "object",
          description: "Describes how to reduce the amount of data exposed to the visual",
          properties: {
            top: {
              type: "object",
              description: "Reduce the data to the Top count items",
              properties: {
                count: {
                  type: "number"
                }
              }
            },
            bottom: {
              type: "object",
              description: "Reduce the data to the Bottom count items",
              properties: {
                count: {
                  type: "number"
                }
              }
            },
            sample: {
              type: "object",
              description: "Reduce the data using a simple Sample of count items",
              properties: {
                count: {
                  type: "number"
                }
              }
            },
            window: {
              type: "object",
              description: "Allow the data to be loaded one window, containing count items, at a time",
              properties: {
                count: {
                  type: "number"
                }
              }
            }
          },
          additionalProperties: false,
          oneOf: [
            {
              required: [
                "top"
              ]
            },
            {
              required: [
                "bottom"
              ]
            },
            {
              required: [
                "sample"
              ]
            },
            {
              required: [
                "window"
              ]
            }
          ]
        },
        "dataViewMapping.dataVolume": {
          description: "Specifies the volume of data the query should return (1-6)",
          type: "number",
          enum: [
            1,
            2,
            3,
            4,
            5,
            6
          ]
        },
        "dataViewMapping.forIn": {
          type: "object",
          description: "Binds this data mapping for all items in a collection",
          properties: {
            in: {
              type: "string",
              description: "The name of a data role to iterate over"
            }
          },
          additionalProperties: false,
          required: [
            "in"
          ]
        },
        objects: {
          type: "object",
          description: "A list of unique property groups",
          patternProperties: {
            "^[\\w\\s-]+$": {
              type: "object",
              description: "Settings for a group of properties",
              properties: {
                displayName: {
                  type: "string",
                  description: "The name shown to the user to describe this group of properties"
                },
                displayNameKey: {
                  type: "string",
                  description: "The localization key for the displayed name in the stringResourced file"
                },
                objectCategory: {
                  type: "number",
                  description: "What aspect of the visual this object controlls (1 = Formatting, 2 = Analytics). Formatting: look & feel, colors, axes, labels etc. Analytics: forcasts, trendlines, reference lines and shapes etc."
                },
                description: {
                  type: "string",
                  description: "A description of this object shown to the user as a tooltip"
                },
                descriptionKey: {
                  type: "string",
                  description: "The localization key for the description in the stringResourced file"
                },
                properties: {
                  type: "object",
                  description: "A list of unique properties contained in this group",
                  patternProperties: {
                    "^[\\w\\s-]+$": {
                      $ref: "#/definitions/object.propertySettings"
                    }
                  },
                  additionalProperties: false
                }
              },
              additionalProperties: false
            }
          },
          additionalProperties: false
        },
        tooltips: {
          type: "object",
          description: "Instructs the host to include tooltips ability",
          properties: {
            supportedTypes: {
              type: "object",
              description: "Instructs the host what tooltip types to support",
              properties: {
                default: {
                  type: "boolean",
                  description: "Instructs the host to support showing default tooltips"
                },
                canvas: {
                  type: "boolean",
                  description: "Instructs the host to support showing canvas tooltips"
                }
              }
            },
            roles: {
              type: "array",
              items: {
                type: "string",
                description: "The name of the data role to bind the tooltips selected info to"
              }
            },
            supportEnhancedTooltips: {
              type: "boolean",
              description: "Indicates whether the visual support modern tooltip feature"
            }
          }
        },
        "object.propertySettings": {
          type: "object",
          description: "Settings for a property",
          properties: {
            displayName: {
              type: "string",
              description: "The name shown to the user to describe this property"
            },
            displayNameKey: {
              type: "string",
              description: "The localization key for the displayed name in the stringResourced file"
            },
            description: {
              type: "string",
              description: "A description of this property shown to the user as a tooltip"
            },
            descriptionKey: {
              type: "string",
              description: "The localization key for the description in the stringResourced file"
            },
            placeHolderText: {
              type: "string",
              description: "Text to display if the field is empty"
            },
            placeHolderTextKey: {
              type: "string",
              description: "The localization key for the placeHolderText in the stringResources file"
            },
            suppressFormatPainterCopy: {
              type: "boolean",
              description: "Indicates whether the Format Painter should ignore this property"
            },
            type: {
              description: "Describes what type of property this is and how it should be displayed to the user",
              $ref: "#/definitions/valueType"
            },
            rule: {
              type: "object",
              description: "Describes substitution rule that replaces property object, described inside the rule, to current property object that contains this rule",
              $ref: "#/definitions/substitutionRule"
            },
            filterState: {
              type: "boolean",
              description: "Indicates whether the property is a part of filtration information"
            }
          },
          additionalProperties: false
        },
        substitutionRule: {
          type: "object",
          description: "Describes substitution rule that replaces property object, described inside the rule, to current property object that contains this rule",
          properties: {
            inputRole: {
              type: "string",
              description: "The name of role. If this role is set, the substitution will be applied"
            },
            output: {
              type: "object",
              description: "Describes what exactly is necessary to replace",
              properties: {
                property: {
                  type: "string",
                  description: "The name of property object that will be replaced"
                },
                selector: {
                  type: "array",
                  description: "The array of selector names. Usually, it contains only one selector -- 'Category'",
                  items: {
                    type: "string",
                    description: "The name of selector"
                  }
                }
              }
            }
          }
        },
        sorting: {
          type: "object",
          description: "Specifies the default sorting behavior for the visual",
          properties: {
            default: {
              type: "object",
              additionalProperties: false
            },
            custom: {
              type: "object",
              additionalProperties: false
            },
            implicit: {
              type: "object",
              description: "implicit sort",
              properties: {
                clauses: {
                  type: "array",
                  items: {
                    type: "object",
                    properties: {
                      role: {
                        type: "string"
                      },
                      direction: {
                        type: "number",
                        description: "Determines sort direction (1 = Ascending, 2 = Descending)",
                        enum: [
                          1,
                          2
                        ]
                      }
                    },
                    additionalProperties: false
                  }
                }
              },
              additionalProperties: false
            }
          },
          additionalProperties: false,
          anyOf: [
            {
              required: [
                "default"
              ]
            },
            {
              required: [
                "custom"
              ]
            },
            {
              required: [
                "implicit"
              ]
            }
          ]
        },
        drilldown: {
          type: "object",
          description: "Defines the visual's drill capability",
          properties: {
            roles: {
              type: "array",
              description: "The drillable role names for this visual",
              items: {
                type: "string",
                description: "The name of the role"
              }
            }
          }
        },
        expandCollapse: {
          type: "object",
          description: "Defines the visual's expandCollapse capability",
          properties: {
            roles: {
              type: "array",
              description: "The expandCollapsed role names for this visual",
              items: {
                type: "string",
                description: "The name of the role"
              }
            },
            addDataViewFlags: {
              type: "object",
              description: "The data view flags",
              defaultValue: {
                type: "boolean",
                description: "Indicates if the DataViewTreeNode will contain the isCollapsed flag by default"
              }
            },
            supportsMerge: {
              type: "boolean",
              description: "Indicates that the expansion state should be updated when query projections change, instead of being reset."
            },
            restoreProjectionsOrderFromBookmark: {
              type: "boolean",
              description: "Indicates that the bookmarked expansion state should be restored even if the query projections order no longer matches the expansion state levels."
            }
          }
        },
        valueType: {
          type: "object",
          properties: {
            bool: {
              type: "boolean",
              description: "A boolean value that will be displayed to the user as a toggle switch"
            },
            enumeration: {
              type: "array",
              description: "A list of values that will be displayed as a drop down list",
              items: {
                type: "object",
                description: "Describes an item in the enumeration list",
                properties: {
                  displayName: {
                    type: "string",
                    description: "The name shown to the user to describe this item"
                  },
                  displayNameKey: {
                    type: "string",
                    description: "The localization key for the displayed name in the stringResourced file"
                  },
                  value: {
                    type: "string",
                    description: "The internal value of this property when this item is selected"
                  }
                }
              }
            },
            fill: {
              type: "object",
              description: "A color value that will be displayed to the user as a color picker",
              properties: {
                solid: {
                  type: "object",
                  description: "A solid color value that will be displayed to the user as a color picker",
                  properties: {
                    color: {
                      oneOf: [
                        {
                          type: "boolean"
                        },
                        {
                          type: "object",
                          properties: {
                            nullable: {
                              description: "Allows the user to select 'no fill' for the color",
                              type: "boolean"
                            }
                          }
                        }
                      ]
                    }
                  }
                }
              }
            },
            fillRule: {
              type: "object",
              description: "A color gradient that will be dispalyed to the user as a minimum (,medium) and maximum color pickers",
              properties: {
                linearGradient2: {
                  type: "object",
                  description: "Two color gradient",
                  properties: {
                    max: {
                      type: "object",
                      description: "Maximum color for gradient",
                      properties: {
                        color: {
                          type: "string"
                        },
                        value: {
                          type: "number"
                        }
                      }
                    },
                    min: {
                      type: "object",
                      description: "Minimum color for gradient",
                      properties: {
                        color: {
                          type: "string"
                        },
                        value: {
                          type: "number"
                        }
                      }
                    },
                    nullColoringStrategy: {
                      type: "object",
                      description: "Null color strategy"
                    }
                  }
                },
                linearGradient3: {
                  type: "object",
                  description: "Three color gradient",
                  properties: {
                    max: {
                      type: "object",
                      description: "Maximum color for gradient",
                      properties: {
                        color: {
                          type: "string"
                        },
                        value: {
                          type: "number"
                        }
                      }
                    },
                    min: {
                      type: "object",
                      description: "Minimum color for gradient",
                      properties: {
                        color: {
                          type: "string"
                        },
                        value: {
                          type: "number"
                        }
                      }
                    },
                    mid: {
                      type: "object",
                      description: "Middle color for gradient",
                      properties: {
                        color: {
                          type: "string"
                        },
                        value: {
                          type: "number"
                        }
                      }
                    },
                    nullColoringStrategy: {
                      type: "object",
                      description: "Null color strategy"
                    }
                  }
                }
              }
            },
            formatting: {
              type: "object",
              description: "A numeric value that will be displayed to the user as a text input",
              properties: {
                labelDisplayUnits: {
                  type: "boolean",
                  description: "Displays a dropdown with common display units (Auto, None, Thousands, Millions, Billions, Trillions)"
                },
                alignment: {
                  type: "boolean",
                  description: "Displays a selector to allow the user to choose left, center, or right alignment"
                },
                fontSize: {
                  type: "boolean",
                  description: "Displays a slider that allows the user to choose a font size in points"
                },
                fontFamily: {
                  type: "boolean",
                  description: "Displays a dropdown with font families"
                },
                formatString: {
                  type: "boolean",
                  description: "Displays dynamic format string"
                }
              },
              additionalProperties: false,
              oneOf: [
                {
                  required: [
                    "labelDisplayUnits"
                  ]
                },
                {
                  required: [
                    "alignment"
                  ]
                },
                {
                  required: [
                    "fontSize"
                  ]
                },
                {
                  required: [
                    "fontFamily"
                  ]
                },
                {
                  required: [
                    "formatString"
                  ]
                }
              ]
            },
            integer: {
              type: "boolean",
              description: "An integer (whole number) value that will be displayed to the user as a text input"
            },
            numeric: {
              type: "boolean",
              description: "A numeric value that will be displayed to the user as a text input"
            },
            filter: {
              oneOf: [
                {
                  type: "boolean"
                },
                {
                  type: "object",
                  properties: {
                    selfFilter: {
                      type: "boolean"
                    }
                  }
                }
              ],
              description: "A filter"
            },
            operations: {
              type: "object",
              description: "A visual operation",
              properties: {
                searchEnabled: {
                  type: "boolean",
                  description: "Turns search ability on"
                }
              }
            },
            text: {
              type: "boolean",
              description: "A text value that will be displayed to the user as a text input"
            },
            scripting: {
              type: "object",
              description: "A text value that will be displayed to the user as a script",
              properties: {
                source: {
                  type: "boolean",
                  description: "A source code"
                }
              }
            },
            geography: {
              type: "object",
              description: "Geographical data",
              properties: {
                address: {
                  type: "boolean"
                },
                city: {
                  type: "boolean"
                },
                continent: {
                  type: "boolean"
                },
                country: {
                  type: "boolean"
                },
                county: {
                  type: "boolean"
                },
                region: {
                  type: "boolean"
                },
                postalCode: {
                  type: "boolean"
                },
                stateOrProvince: {
                  type: "boolean"
                },
                place: {
                  type: "boolean"
                },
                latitude: {
                  type: "boolean"
                },
                longitude: {
                  type: "boolean"
                }
              }
            }
          },
          additionalProperties: false,
          oneOf: [
            {
              required: [
                "bool"
              ]
            },
            {
              required: [
                "enumeration"
              ]
            },
            {
              required: [
                "fill"
              ]
            },
            {
              required: [
                "fillRule"
              ]
            },
            {
              required: [
                "formatting"
              ]
            },
            {
              required: [
                "integer"
              ]
            },
            {
              required: [
                "numeric"
              ]
            },
            {
              required: [
                "text"
              ]
            },
            {
              required: [
                "geography"
              ]
            },
            {
              required: [
                "scripting"
              ]
            },
            {
              required: [
                "filter"
              ]
            },
            {
              required: [
                "operations"
              ]
            }
          ]
        },
        subtotals: {
          type: "object",
          description: "Specifies the subtotal request customizations applied to the outgoing data query",
          properties: {
            matrix: {
              description: "Defines the subtotal customizations of the outgoing data query of a matrix-dataview visual",
              $ref: "#/definitions/subtotals.matrix"
            }
          },
          requires: [
            "matrix"
          ]
        },
        "subtotals.matrix": {
          type: "object",
          description: "Specifies the subtotal customizations of the outgoing data query of a matrix-dataview visual",
          properties: {
            rowSubtotals: {
              type: "object",
              description: "Indicates if the subtotal data should be requested for all fields in the rows field well",
              properties: {
                propertyIdentifier: {
                  type: "object",
                  properties: {
                    objectName: {
                      type: "string"
                    },
                    propertyName: {
                      type: "string"
                    }
                  }
                },
                defaultValue: {
                  type: "boolean"
                }
              }
            },
            rowSubtotalsPerLevel: {
              type: "object",
              description: "Indicates if the subtotal data can be toggled for individual fields in the rows field well",
              properties: {
                propertyIdentifier: {
                  type: "object",
                  properties: {
                    objectName: {
                      type: "string"
                    },
                    propertyName: {
                      type: "string"
                    }
                  }
                },
                defaultValue: {
                  type: "boolean"
                }
              }
            },
            columnSubtotals: {
              type: "object",
              description: "Indicates if the subtotal data should be requested for all fields in the columns field well",
              properties: {
                propertyIdentifier: {
                  type: "object",
                  properties: {
                    objectName: {
                      type: "string"
                    },
                    propertyName: {
                      type: "string"
                    }
                  }
                },
                defaultValue: {
                  type: "boolean"
                }
              }
            },
            columnSubtotalsPerLevel: {
              type: "object",
              description: "Indicates if the subtotal data can be toggled for individual fields in the columns field well",
              properties: {
                propertyIdentifier: {
                  type: "object",
                  properties: {
                    objectName: {
                      type: "string"
                    },
                    propertyName: {
                      type: "string"
                    }
                  }
                },
                defaultValue: {
                  type: "boolean"
                }
              }
            },
            levelSubtotalEnabled: {
              type: "object",
              description: "Unlike all other properites, this property is applied to individual rows/columns. The property indicates if the subtotals are requested for the row/column",
              properties: {
                propertyIdentifier: {
                  type: "object",
                  properties: {
                    objectName: {
                      type: "string"
                    },
                    propertyName: {
                      type: "string"
                    }
                  }
                },
                defaultValue: {
                  type: "boolean"
                }
              }
            },
            rowSubtotalsType: {
              type: "object",
              description: "Indicates location of row subtotals locations (Top, Bottom). Top means subtotals located at the start of datasource and calculated even before all datasource rows fetched, Bottom means subtotals located at the end of datasource and shown only after all rows are fetched",
              properties: {
                propertyIdentifier: {
                  type: "object",
                  properties: {
                    objectName: {
                      type: "string"
                    },
                    propertyName: {
                      type: "string"
                    }
                  }
                },
                defaultValue: {
                  type: "string",
                  enum: [
                    "Top",
                    "Bottom"
                  ]
                }
              }
            }
          },
          requires: [
            "matrix"
          ]
        },
        migration: {
          type: "object",
          description: "Defines the supported APIs for migration",
          properties: {
            filter: {
              $ref: "#/definitions/migration.filter"
            }
          }
        },
        "migration.filter": {
          type: "object",
          description: "Defines the capabilities for migrating the filter API",
          properties: {
            shouldUseIdentityFilter: {
              type: "boolean",
              description: "Indicates whether the new filter should migrate to an identity filter"
            }
          }
        },
        dataReductionCustomization: {
          type: "object",
          description: "Specifies the dataReduction request customizations applied to the outgoing data query",
          properties: {
            matrix: {
              description: "Defines the dataReduction customizations of the outgoing data query of a matrix-dataview visual",
              $ref: "#/definitions/dataReductionCustomization.matrix"
            },
            table: {
              description: "Defines the dataReduction customizations of the outgoing data query of a table-dataview visual",
              $ref: "#/definitions/dataReductionCustomization.table"
            },
            categorical: {
              description: "Defines the dataReduction customizations of the outgoing data query of a categorical-dataview visual",
              $ref: "#/definitions/dataReductionCustomization.categorical"
            }
          }
        },
        "dataReductionCustomization.matrix": {
          type: "object",
          description: "Specifies the subtotal customizations of the outgoing data query of a matrix-dataview visual",
          properties: {
            rowCount: {
              type: "object",
              description: "Indicates the row count for the data reduction applied for matrix dataview",
              properties: {
                propertyIdentifier: {
                  type: "object",
                  properties: {
                    objectName: {
                      type: "string"
                    },
                    propertyName: {
                      type: "string"
                    }
                  }
                },
                defaultValue: {
                  type: "number"
                }
              }
            },
            columnCount: {
              type: "object",
              description: "Indicates the column count for the data reduction applied for matrix dataview",
              properties: {
                propertyIdentifier: {
                  type: "object",
                  properties: {
                    objectName: {
                      type: "string"
                    },
                    propertyName: {
                      type: "string"
                    }
                  }
                },
                defaultValue: {
                  type: "number"
                }
              }
            }
          },
          requires: [
            "matrix"
          ]
        },
        "dataReductionCustomization.table": {
          type: "object",
          description: "Specifies the subtotal customizations of the outgoing data query of a table-dataview visual",
          properties: {
            rowCount: {
              type: "object",
              description: "Indicates the row count for the data reduction applied for table dataview",
              properties: {
                propertyIdentifier: {
                  type: "object",
                  properties: {
                    objectName: {
                      type: "string"
                    },
                    propertyName: {
                      type: "string"
                    }
                  }
                },
                defaultValue: {
                  type: "number"
                }
              }
            }
          },
          requires: [
            "table"
          ]
        },
        "dataReductionCustomization.categorical": {
          type: "object",
          description: "Specifies the subtotal customizations of the outgoing data query of a categorical-dataview visual",
          properties: {
            categoryCount: {
              type: "object",
              description: "Indicates the category count for the data reduction applied for categorical dataview",
              properties: {
                propertyIdentifier: {
                  type: "object",
                  properties: {
                    objectName: {
                      type: "string"
                    },
                    propertyName: {
                      type: "string"
                    }
                  }
                },
                defaultValue: {
                  type: "number"
                }
              }
            },
            groupedValuesCount: {
              type: "object",
              description: "Indicates the grouped value count for the data reduction applied for categorical dataview",
              properties: {
                propertyIdentifier: {
                  type: "object",
                  properties: {
                    objectName: {
                      type: "string"
                    },
                    propertyName: {
                      type: "string"
                    }
                  }
                },
                defaultValue: {
                  type: "number"
                }
              }
            }
          },
          requires: [
            "categorical"
          ]
        }
      }
    };
  }
});

// node_modules/powerbi-visuals-api/schema.pbiviz.json
var require_schema_pbiviz = __commonJS({
  "node_modules/powerbi-visuals-api/schema.pbiviz.json"(exports, module) {
    module.exports = {
      type: "object",
      properties: {
        apiVersion: {
          type: "string",
          description: "Version of the IVisual API"
        },
        author: {
          type: "object",
          description: "Information about the author of the visual",
          properties: {
            name: {
              type: "string",
              description: "Name of the visual author. This is displayed to users."
            },
            email: {
              type: "string",
              description: "E-mail of the visual author. This is displayed to users for support."
            }
          }
        },
        assets: {
          type: "object",
          description: "Assets used by the visual",
          properties: {
            icon: {
              type: "string",
              description: "A 20x20 png icon used to represent the visual"
            }
          }
        },
        externalJS: {
          type: "array",
          description: "An array of relative paths to 3rd party javascript libraries to load",
          items: {
            type: "string"
          }
        },
        stringResources: {
          type: "array",
          description: "An array of relative paths to string resources to load",
          items: {
            type: "string"
          },
          uniqueItems: true
        },
        style: {
          type: "string",
          description: "Relative path to the stylesheet (less) for the visual"
        },
        capabilities: {
          type: "string",
          description: "Relative path to the visual capabilities json file"
        },
        visual: {
          type: "object",
          description: "Details about this visual",
          properties: {
            description: {
              type: "string",
              description: "What does this visual do?"
            },
            name: {
              type: "string",
              description: "Internal visual name"
            },
            displayName: {
              type: "string",
              description: "A friendly name"
            },
            externals: {
              type: "array",
              description: "External files (such as JavaScript) that you would like to include"
            },
            guid: {
              type: "string",
              description: "Unique identifier for the visual"
            },
            visualClassName: {
              type: "string",
              description: "Class of your IVisual"
            },
            icon: {
              type: "string",
              description: "Icon path"
            },
            version: {
              type: "string",
              description: "Visual version"
            },
            gitHubUrl: {
              type: "string",
              description: "Url to the github repository for this visual"
            },
            supportUrl: {
              type: "string",
              description: "Url to the support page for this visual"
            }
          }
        }
      }
    };
  }
});

// node_modules/powerbi-visuals-api/schema.dependencies.json
var require_schema_dependencies = __commonJS({
  "node_modules/powerbi-visuals-api/schema.dependencies.json"(exports, module) {
    module.exports = {
      type: "object",
      properties: {
        cranPackages: {
          type: "array",
          description: "An array of the Cran packages required for the custom R visual script to operate",
          items: {
            $ref: "#/definitions/cranPackage"
          }
        }
      },
      definitions: {
        cranPackage: {
          type: "object",
          description: "cranPackage - Defines the name and displayName of a required Cran package",
          properties: {
            name: {
              type: "string",
              description: "The name for this Cran package"
            },
            displayName: {
              type: "string",
              description: "The name for this Cran package that is shown to the user"
            },
            url: {
              type: "string",
              description: "A url for package documentation in Cran website"
            }
          },
          required: [
            "name",
            "url"
          ],
          additionalProperties: false
        }
      }
    };
  }
});

// node_modules/powerbi-visuals-api/schema.stringResources.json
var require_schema_stringResources = __commonJS({
  "node_modules/powerbi-visuals-api/schema.stringResources.json"(exports, module) {
    module.exports = {
      type: "object",
      properties: {
        locale: {
          $ref: "#/definitions/localeOptions"
        },
        values: {
          type: "object",
          description: "translations for the display name keys in the capabilities",
          additionalProperties: { type: "string" }
        }
      },
      required: ["locale"],
      definitions: {
        localeOptions: {
          description: "Specifies the locale key from a list of supported locales",
          type: "string",
          enum: [
            "ar-SA",
            "bg-BG",
            "ca-ES",
            "cs-CZ",
            "da-DK",
            "de-DE",
            "el-GR",
            "en-US",
            "es-ES",
            "et-EE",
            "eu-ES",
            "fi-FI",
            "fr-FR",
            "gl-ES",
            "he-IL",
            "hi-IN",
            "hr-HR",
            "hu-HU",
            "id-ID",
            "it-IT",
            "ja-JP",
            "kk-KZ",
            "ko-KR",
            "lt-LT",
            "lv-LV",
            "ms-MY",
            "nb-NO",
            "nl-NL",
            "pl-PL",
            "pt-BR",
            "pt-PT",
            "ro-RO",
            "ru-RU",
            "sk-SK",
            "sl-SI",
            "sr-Cyrl-RS",
            "sr-Latn-RS",
            "sv-SE",
            "th-TH",
            "tr-TR",
            "uk-UA",
            "vi-VN",
            "zh-CN",
            "zh-TW"
          ]
        }
      }
    };
  }
});

// node_modules/powerbi-visuals-api/index.js
var require_powerbi_visuals_api = __commonJS({
  "node_modules/powerbi-visuals-api/index.js"(exports) {
    var semver = require_semver2();
    var packageVersion = require_package().version;
    var apiVersion = `${semver.major(packageVersion)}.${semver.minor(packageVersion)}.0`;
    exports.version = apiVersion;
    exports.schemas = {
      capabilities: require_schema_capabilities(),
      pbiviz: require_schema_pbiviz(),
      dependencies: require_schema_dependencies(),
      stringResources: require_schema_stringResources()
    };
  }
});
export default require_powerbi_visuals_api();
//# sourceMappingURL=powerbi-visuals-api.js.map
